use ec::bjj::BabyJubJubParams;
use ec::Curve;
use ec::scalar_field::ScalarField;
use std::field::bn254::assert_lt;
use std::hash::poseidon::bn254::hash_2 as poseidon;

// The maximum depth of the Merkle Tree the inclusion proof will be coming from.
// This value can get updated by overwriting this line.
pub global MAX_DEPTH: u32 = 10;

// Generator point of Baby Jubjub curve.
// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13
global BASE8: [Field; 2] = [
    5299619240641551281634865583518297030282874472190772894086521144482721001553,
    16950150798460657717958625567821834550301663161624707787222815936182638968203,
];

// This is a 251 bit value.
global L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

// There are 3 main steps in the Noir program.
// - The first part generates the Semaphore identity by obtaining
//   the public key from the secret key and consequently hash the public key.
//   This resulting hash is the identityCommitment.
// - In the second part, it is verified that the identityCommitment is indeed
//   part of the merkle tree by verifying the merkle proof.
// - In the third part the nullifier is generated by hashing the hashedScope
//   with the secret key.

// There are 4 public values: the Merkle tree root, hashed scope, hashed message,
// and the nullifier. Whether the scope and message are actually hashed doesn't
// affect the circuit; the names just match how they're used in the Semaphore SDK.
//
// The message is tied to the circuit by adding it as a (public) input to the circuit.
fn main(
    secretKey: Field,
    indexes: Field, // a single field representing the index-bits for the merkle proof
    hashPath: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof
    merkleProofLength: u32, // the number of non-zero elements in hashPath
    merkleTreeRoot: pub Field,
    hashedScope: pub Field,
    hashedMessage: pub Field,
) -> pub Field {
    // Part 1
    // Ensure secret_key < l.
    assert_lt(secretKey, L);

    // Identity generation.
    // The public key is derived by multiplying the generator point with the secret key,
    // interpreted as a scalar.
    let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };
    // ScalarField is parameterised by the number of 4-bit slices it contains.
    // Since secret key is already known to be max 251 bits, there are 63 slices.
    let secretScalar: ScalarField<63> = ScalarField::from(secretKey);
    let pubkey = generator.mul(secretScalar);

    // Obtain the identity commitment by hashing the public key
    let identityCommitment = poseidon([pubkey.x, pubkey.y]);

    // Part 2
    // Verifies membership by repeatedly hashing with the elements from the merkle proof.
    // Depending on the index bit, we swap the siblings for hashing or not.
    // Finally, it is checked the resulting root equals the expected one.
    // The index bits are bounded by the max depth of the tree.
    let index_bits: [u1; MAX_DEPTH] = indexes.to_le_bits();
    let mut node = identityCommitment;
    for i in 0..MAX_DEPTH {
        if i < merkleProofLength {
            let sibling = hashPath[i];
            let (left, right) = if index_bits[i] == 0 {
                (node, sibling)
            } else {
                (sibling, node)
            };
            node = poseidon([left, right]);
        }
    }

    assert(node == merkleTreeRoot);

    // Part 3
    // Obtain the nullifier by hashing the hashed scope and secret key.
    let nullifier = poseidon([hashedScope, secretKey]);

    nullifier
}

#[test]
fn pass_merkleproof_len1() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;
    let indexes = 1;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;
    let merkleProofLength = 1;
    let merkleTreeRoot =
        14749601632619677010117355190090900871659822873947496064081607008658671249718;
    let hashedScope = 32;
    let messageInput = 43;

    let nullifierOutput = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );

    assert(
        nullifierOutput
            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,
    );
}

#[test]
fn pass_merkleproof_len2() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;
    let indexes = 3;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 222;
    hashPath[1] = 5580148635681152038824579634153994374025422922042242905608547916566050510583;
    let merkleProofLength = 2;
    let merkleTreeRoot =
        15463896243170667872144918581954291954064138644202866266871757140238856236252;
    let hashedScope = 32;
    let messageInput = 43;

    let nullifierOutput = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );

    assert(
        nullifierOutput
            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,
    );
}

#[test]
fn pass_merkleproof_len10() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;
    let indexes = 1023;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 1023;
    hashPath[1] = 7703609393926148861806470850414101587282113463695008072842235608796379066550;
    hashPath[2] = 11844355347052921836263554861941946966048634969958623466081587590542465759133;
    hashPath[3] = 19139877065885635288462009770448247355705152266967089952432395406553642434273;
    hashPath[4] = 15968895708437223385516840363948747630018846839139338811061474982723265688336;
    hashPath[5] = 1157389113544196424312834359849712044068249869160475042631259223915679649526;
    hashPath[6] = 9850169485007128596840836882853679679304108948486378818337816937810456934767;
    hashPath[7] = 7328698264973484546168581905250553935177218888248684409634832044961836320061;
    hashPath[8] = 3637363514134115024343666241307349483158812906758472113070175697206757306389;
    hashPath[9] = 7516686158158401448998320090358910253731148596461412688165783659432576569650;
    let merkleProofLength = 10;
    let merkleTreeRoot =
        2057311462964865392236711171061056405638996999335557516757935831793017666139;
    let hashedScope = 32;
    let messageInput = 43;

    let nullifierOutput = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );

    assert(
        nullifierOutput
            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,
    );
}

#[test(should_fail)]
fn fail_secret_key_outofrange() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373042;
    let indexes = 1;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;
    let merkleProofLength = 1;
    let merkleTreeRoot =
        14749601632619677010117355190090900871659822873947496064081607008658671249718;
    let hashedScope = 32;
    let messageInput = 43;

    let _ = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );
}

#[test(should_fail)]
fn fail_invalid_merkleproof() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;
    let indexes = 1;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 2;
    let merkleProofLength = 1;
    let merkleTreeRoot =
        14749601632619677010117355190090900871659822873947496064081607008658671249718;
    let hashedScope = 32;
    let messageInput = 43;

    let _ = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );
}

#[test(should_fail)]
fn fail_other_merkleroot() {
    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;
    let indexes = 1;
    let mut hashPath = [0; MAX_DEPTH];
    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;
    let merkleProofLength = 1;
    let merkleTreeRoot = 2;
    let hashedScope = 32;
    let messageInput = 43;

    let _ = main(
        secretKey,
        indexes,
        hashPath,
        merkleProofLength,
        merkleTreeRoot,
        hashedScope,
        messageInput,
    );
}
